<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Blog Atom Feed"><title data-react-helmet="true">【翻译】理解JS的函数调用和‘this’的指向 / Understanding JavaScript Function Invocation and &quot;this&quot; | My Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://tomoya06.github.io//docs/note/js-this"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="【翻译】理解JS的函数调用和‘this’的指向 / Understanding JavaScript Function Invocation and &quot;this&quot; | My Site"><meta data-react-helmet="true" name="description" content="原文出自Yehuda的这篇博客，是在Typescript的中文教程里看到的。"><meta data-react-helmet="true" property="og:description" content="原文出自Yehuda的这篇博客，是在Typescript的中文教程里看到的。"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://tomoya06.github.io//docs/note/js-this"><link data-react-helmet="true" rel="alternate" href="https://tomoya06.github.io//docs/note/js-this" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://tomoya06.github.io//docs/note/js-this" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.9e7bfb73.css">
<link rel="preload" href="/assets/js/runtime~main.e7db21f9.js" as="script">
<link rel="preload" href="/assets/js/main.5dbb51fa.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">My Site</b></a><a class="navbar__item navbar__link" href="/docs/codezone_intro">CodeZone</a><a class="navbar__item navbar__link" href="/docs/剑指offer/剑指offer_intro">剑指offer</a><a class="navbar__item navbar__link" href="/docs/剑指offer专项版/剑指offer专项版_intro">剑指offer专项版</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs/note_intro">随手记</a><a class="navbar__item navbar__link" href="/blog">博客</a><a href="https://github.com/tomoya06" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><main class="docMainContainer_3ufF docMainContainerEnhanced_3NYZ"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>【翻译】理解JS的函数调用和‘this’的指向 / Understanding JavaScript Function Invocation and &quot;this&quot;</h1></header><blockquote><p>原文出自Yehuda的<a href="https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/" target="_blank" rel="noopener noreferrer">这篇博客</a>，是在Typescript的中文教程里看到的。</p></blockquote><p>JS的函数调用一直以来给不少人带来疑惑，其中<code>this</code>的语义是人们抱怨的最多的。</p><p>在我看来，首先理解了函数调用的原始核心语法，然后弄清楚其他调用函数的语法糖，这些疑惑就能解决了。实际上这正式ECMA规范所设计的思路。在某种程度上，这篇文章是ECMA规范的简化版，不过基本理念都是一样的。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="核心源码"></a>核心源码<a class="hash-link" href="#核心源码" title="Direct link to heading">#</a></h2><p>首先来看JS函数调用的核心，<code>Function</code>类的<code>call</code>方法【1】。<code>call</code>方法的逻辑很直白：</p><ol><li>把从第二个起的所有参数放进一个参数列表，如<code>argList</code>中</li><li>把第一个参数定为<code>thisValue</code></li><li>执行<code>function</code>，把<code>this</code>指向<code>thisValue</code>，<code>argList</code>作为参数列表</li></ol><p>例如：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function hello(thing) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(this + &quot; says hello &quot; + thing);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">hello.call(&quot;Yehuda&quot;, &quot;world&quot;) //=&gt; Yehuda says hello world</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>可以看到，在执行<code>hello</code>函数时我们把<code>this</code>指向<code>&quot;Yehuda&quot;</code>，传入单个参数<code>&quot;world&quot;</code>。这就是JS函数调用的核心源码。你可以把其他的函数调用的语法都看成是这个源码的语法糖。</p><blockquote><p>【1】在<a href="http://es5.github.io/#x15.3.4.4" target="_blank" rel="noopener noreferrer">ES5规范</a>中，<code>call</code>还是另一个更低层次的源码的语法糖，但包装得并不复杂，所以在这里直接简化了。文末有更多资料。</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="简单的函数调用"></a>简单的函数调用<a class="hash-link" href="#简单的函数调用" title="Direct link to heading">#</a></h2><p>显然每次都用<code>call</code>来调用函数太累赘了。JS允许我们直接使用括号来调用函数，如<code>hello(&quot;world&quot;)</code>，这个就是一个语法糖了：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function hello(thing) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&quot;Hello &quot; + thing);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// this:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">hello(&quot;world&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// desugars to:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">hello.call(window, &quot;world&quot;);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在ES5的严格模式(strict mode)下，有一点小小的改动：【2】</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// this:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">hello(&quot;world&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// desugars to:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">hello.call(undefined, &quot;world&quot;);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>所以简单来讲，通过括号的函数调用<code>fn(...args)</code>等价于<code>fn.call(window [ES5-strict: undefined], ...args)</code>。</p><p>要注意这对匿名函数来讲也是成立的：<code>(function() {})()</code>等价于<code>(function() {}).call(window [ES5-strict: undefined)</code></p><blockquote><p>【2】实际上原作者说他撒了个小谎。ES5规范说的是给<code>thisValue</code>所绑定的几乎都是<code>undefined</code>（The ECMAScript 5 spec says that undefined is (almost) always passed），但他认为不在严格模式时<code>thisValue</code>应该绑定到<code>global</code>对象。<em>This allows strict mode callers to avoid breaking existing non-strict-mode libraries.</em></p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="成员函数"></a>成员函数<a class="hash-link" href="#成员函数" title="Direct link to heading">#</a></h2><p>另一个常见的场景是调用一个对象的成员函数，如<code>person.hello()</code>。这时候函数调用的语法糖分析如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var person = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  name: &quot;Brendan Eich&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  hello: function(thing) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(this + &quot; says hello &quot; + thing);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// this:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">person.hello(&quot;world&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// desugars to this:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">person.hello.call(person, &quot;world&quot;);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>要注意，无论<code>hello</code>函数是如何添加到这个对象的，效果都是一样的，记得事先声明一个独立的<code>hello</code>函数即可。现在来看下把<code>hello</code>函数动态添加到某个对象，调用起来是什么效果：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function hello(thing) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(this + &quot; says hello &quot; + thing);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">person = { name: &quot;Brendan Eich&quot; }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">person.hello = hello;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">person.hello(&quot;world&quot;) // still desugars to person.hello.call(person, &quot;world&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">hello(&quot;world&quot;) // &quot;[object DOMWindow]world&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>注意到函数对<code>this</code>的指向不是恒定不变的，每次都是根据调用函数方法的不同来执行不同的绑定。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="使用functionprototypebind"></a>使用<code>Function.prototype.bind</code><a class="hash-link" href="#使用functionprototypebind" title="Direct link to heading">#</a></h2><p>有时候会想让一个函数始终保持相同的<code>this</code>指向，开发者会使用闭包来实现这个目的：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var person = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  name: &quot;Brendan Eich&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  hello: function(thing) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(this.name + &quot; says hello &quot; + thing);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var boundHello = function(thing) { </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return person.hello.call(person, thing); </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">boundHello(&quot;world&quot;);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>尽管<code>boundHello(&quot;world&quot;)</code>最终会解析成<code>boundHello.call(window, &quot;world&quot;)</code>，但之前的操作已经把<code>this</code>绑定回我们想要的对象了。</p><p>我们还可以把这样的转换封装成通用模块：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var bind = function(func, thisValue) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return function() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return func.apply(thisValue, arguments);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var boundHello = bind(person.hello, person);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">boundHello(&quot;world&quot;) // &quot;Brendan Eich says hello world&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>要理解这段代码，你只需直到另外两个信息：首先，<code>arguments</code>是一个类数组对象，表示所有传给这个函数的对象；其次，<code>apply</code>的作用和<code>call</code>类似，但前者一次接收一个类数组对象作为传参，后者接收多个参数。</p><p>这里的<code>bind</code>函数简单返回一个新的函数。在调用<code>bind()</code>时，它又会调用之前传参进去的函数，并且把后者的<code>this</code>绑定到第二个参数。</p><p>因为这种用法也很常见，所以ES5引入了一个新的方法<code>bind</code>，适用于所有<code>Function</code>类对象，效果如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var boundHello = person.hello.bind(person);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">boundHello(&quot;world&quot;) // &quot;Brendan Eich says hello world&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>如果你需要写一个（带有<code>this</code>，但其指向有特定需要的）回调函数，这种写法就很有用：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var person = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  name: &quot;Alex Russell&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  hello: function() { console.log(this.name + &quot; says hello world&quot;); }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">$(&quot;#some-div&quot;).click(person.hello.bind(person));</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// when the div is clicked, &quot;Alex Russell says hello world&quot; is printed</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>当然这种写法还是有点拗手。TC39（ECMAScript标准制定委员会）还在努力寻找一种更优雅的解决方案。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="jquery"></a>jQuery<a class="hash-link" href="#jquery" title="Direct link to heading">#</a></h2><blockquote><p>本段不做翻译。</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="后记编者作"></a>后记（编者作）<a class="hash-link" href="#后记编者作" title="Direct link to heading">#</a></h2><p>有好几处的描述我对原本的规范描述做了简化，其中最关键的一点是我把<code>func.call</code>称为源码（primitive）。实际上在规范里，<code>function.call</code>和<code>[obj.]func()</code>还有更深一层的原源码。</p><p>但来看一下ES5标准中<code>func.call</code>的声明（译者：即ES5标准里<code>Function.prototype.call (thisArg [ , arg1 [ , arg2, … ] ] ) </code>的描述）：</p><ol><li>如果<code>IsCallable(func)</code>为<code>false</code>，抛出<code>TypeError</code>错误</li><li>将<code>argList</code>初始化为空数组</li><li>如果这个函数传入了多个参数，将这些参数从左往右加入到<code>argList</code>，从<code>arg1</code>开始标记</li><li>返回调用<code>func</code>内置方法<code>[[call]]</code>的结果，调用时把<code>thisArg</code>赋给<code>this</code>，传入<code>argList</code>作为参数队列</li></ol><p>可以看到，这只是一段很简单的绑定到<code>[[call]]</code>操作的JS代码。</p><p>如果你去看调用函数的定义，头7步都是在初始化<code>thisValue</code>和<code>argList</code>，最后一步是“返回调用<code>func</code>内置方法<code>[[call]]</code>的结果，调用时把<code>thisArg</code>赋给<code>this</code>，传入<code>argList</code>作为参数队列（<em>Return the result of calling the [[Call]] internal method on func, providing thisValue as the this value and providing the list argList as the argument values.</em>）”</p><p>一旦<code>argList</code>和<code>thisValue</code>准备好之后，之后的工作原理都是一样的了。</p><p>所以我偷了个小懒，但我把ES5规范里的描述都拎出来了，他们的意义都是一样的。</p><p>还有一些其他用法，比如跟<code>with</code>相关的用法，在这里我没有涉及。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags:</b><ul class="tags_2ga9 padding--none margin-left--sm"><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/java-script">JavaScript</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/前端">前端</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#核心源码" class="table-of-contents__link">核心源码</a></li><li><a href="#简单的函数调用" class="table-of-contents__link">简单的函数调用</a></li><li><a href="#成员函数" class="table-of-contents__link">成员函数</a></li><li><a href="#使用functionprototypebind" class="table-of-contents__link">使用<code>Function.prototype.bind</code></a></li><li><a href="#jquery" class="table-of-contents__link">jQuery</a></li><li><a href="#后记编者作" class="table-of-contents__link">后记（编者作）</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">快捷方式</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/剑指offer/剑指offer_intro">剑指offer题库</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/剑指offer专项版/剑指offer专项版_intro">剑指offer专项版题库</a></li></ul></div><div class="col footer__col"><div class="footer__title">联系我</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/tomoya06" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.instagram.com/pjh_tomoya06/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Instagram<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.linkedin.com/in/tomoya06/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>LinkedIn<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">我在看...</div><ul class="footer__items"><li class="footer__item"><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>TypeSctipt<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.instagram.com/russian_romantics/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>俄罗斯烂漫<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.youtube.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>闲暇时光 ☕<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 tomoya06's HomePage, Heavelop Inc. <br>Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.e7db21f9.js"></script>
<script src="/assets/js/main.5dbb51fa.js"></script>
</body>
</html>