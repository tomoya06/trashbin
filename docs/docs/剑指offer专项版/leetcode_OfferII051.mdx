---
tags:
  - æ ‘
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - åŠ¨æ€è§„åˆ’
  - äºŒå‰æ ‘
  - å‰‘æŒ‡offerä¸“é¡¹ç‰ˆ
id: leetcode_OfferII051
title: ğŸ”´ å‰‘æŒ‡ Offer II 051. èŠ‚ç‚¹ä¹‹å’Œæœ€å¤§çš„è·¯å¾„
ques_id: OfferII051
platform: leetcode
online_link: https://leetcode-cn.com/problems/jC7MId/
online_name: èŠ‚ç‚¹ä¹‹å’Œæœ€å¤§çš„è·¯å¾„
level: h
---

export const Highlight = ({children, color}) => (
  <span
    style={{
      backgroundColor: color,
      borderRadius: '2px',
      color: '#fff',
      padding: '0.2rem',
    }}>
    {children}
  </span>
);

:::tip LeetCode æç¤º

é¢˜ç›®éš¾åº¦ <Highlight color="#ff375f">å›°éš¾</Highlight>

åŸé¢˜é“¾æ¥ [ğŸ”— leetcode](https://leetcode-cn.com/problems/jC7MId/)

:::

## é¢˜è§£1

æœ‰ç‚¹å‘çˆ¹ã€‚æ€è·¯è·Ÿå®˜æ–¹é¢˜è§£æ˜¯å·®ä¸å¤šçš„ï¼Œä½†æˆ‘çš„å†™æ³•å°±æ˜¯è¶…æ—¶äº†ã€‚

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private int maxVal;

    // åªè¿”å›[a]ï¼Œaè¡¨ç¤ºä»è¿™ä¸ªç‚¹å¾€å­èŠ‚ç‚¹çš„æœ€å¤§å€¼ï¼›bè¡¨ç¤ºç©¿è¿‡è¿™ä¸ªç‚¹çš„æœ€å¤§å€¼
    private int dfs(TreeNode node) {
        int leftRes = 0, rightRes = 0, myRes = node.val, throughRes = node.val;
        
        if (node.left != null) {
            leftRes = dfs(node.left);
        }
        if (node.right != null) {
            rightRes = dfs(node.right);
        }

        myRes += Math.max(Math.max(leftRes, rightRes), 0);
        throughRes += Math.max(leftRes + rightRes, 0);

        maxVal = Math.max(Math.max(myRes, throughRes), maxVal);

        return myRes;
    }

    public int maxPathSum(TreeNode root) {
        maxVal = Integer.MIN_VALUE;

        dfs(root);

        return maxVal;
    }
}

```

å®˜æ–¹é¢˜è§£æ˜¯è¿™æ ·ï¼š

```java
class Solution {
    int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxSum;
    }

    public int maxGain(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        // é€’å½’è®¡ç®—å·¦å³å­èŠ‚ç‚¹çš„æœ€å¤§è´¡çŒ®å€¼
        // åªæœ‰åœ¨æœ€å¤§è´¡çŒ®å€¼å¤§äº 0 æ—¶ï¼Œæ‰ä¼šé€‰å–å¯¹åº”å­èŠ‚ç‚¹
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);

        // èŠ‚ç‚¹çš„æœ€å¤§è·¯å¾„å’Œå–å†³äºè¯¥èŠ‚ç‚¹çš„å€¼ä¸è¯¥èŠ‚ç‚¹çš„å·¦å³å­èŠ‚ç‚¹çš„æœ€å¤§è´¡çŒ®å€¼
        int priceNewpath = node.val + leftGain + rightGain;

        // æ›´æ–°ç­”æ¡ˆ
        maxSum = Math.max(maxSum, priceNewpath);

        // è¿”å›èŠ‚ç‚¹çš„æœ€å¤§è´¡çŒ®å€¼
        return node.val + Math.max(leftGain, rightGain);
    }
}
```

è¿™ä¸æ˜¯ä¸€æ¯›ä¸€æ ·å—ï¼
