---
tags:
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - å¹¿åº¦ä¼˜å…ˆæœç´¢
  - å›¾
  - æ‹“æ‰‘æ’åº
  - å‰‘æŒ‡offerä¸“é¡¹ç‰ˆ
id: leetcode_OfferII113
title: ğŸŸ¡ å‰‘æŒ‡ Offer II 113. è¯¾ç¨‹é¡ºåº
ques_id: OfferII113
platform: leetcode
online_link: https://leetcode-cn.com/problems/QA2IGt/
online_name: è¯¾ç¨‹é¡ºåº
level: m
---

export const Highlight = ({children, color}) => (
  <span
    style={{
      backgroundColor: color,
      borderRadius: '2px',
      color: '#fff',
      padding: '0.2rem',
    }}>
    {children}
  </span>
);

:::tip LeetCode æç¤º

é¢˜ç›®éš¾åº¦ <Highlight color="#ffc01e">ä¸­ç­‰</Highlight>

åŸé¢˜é“¾æ¥ [ğŸ”— leetcode](https://leetcode-cn.com/problems/QA2IGt/)

:::

## é¢˜è§£1

è‡ªå·±æ€è€ƒçš„ç»“æœã€‚æœ‰ç‚¹ç»•ã€‚

```java
class Solution {
    private Map<Integer, List<Integer>> route = new HashMap<>();
    private Map<Integer, List<Integer>> parents = new HashMap<>();
    private Set<Integer> canBeHead = new HashSet<>();

    private Set<Integer> visited;

    private void travel(int startNode) {
        visited = new LinkedHashSet<>();
        for (int head: canBeHead) {
            dfs(head);
        }
    }

    private void dfs(int node) {
        if (visited.contains(node)) {
            return;
        }
        visited.add(node);
        if (route.get(node) == null) {
            return;
        }
        for (int nxt : route.get(node)) {
            boolean flag = true;
            for (int parent : parents.getOrDefault(nxt, Collections.emptyList())) {
                if (!visited.contains(parent)) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                dfs(nxt);
            }
        }
    }


    public int[] findOrder(int numCourses, int[][] prerequisites) {
        for (int i=0; i<numCourses; i+= 1){
            canBeHead.add(i);
        }
        for (var pre: prerequisites) {
            canBeHead.remove(pre[0]);

            if (route.get(pre[1]) == null) {
                route.put(pre[1], new ArrayList<Integer>());
            }
            route.get(pre[1]).add(pre[0]);

            if (parents.get(pre[0]) == null) {
                parents.put(pre[0], new ArrayList<Integer>());
            }
            parents.get(pre[0]).add(pre[1]);
        }
        if (canBeHead.size() == 0) {
            return new int[0];
        }

        for (Integer head : canBeHead) {
            travel(head);
            if (visited.size() == numCourses) {
                int[] ans = new int[numCourses];
                int cnt = 0;
                for (Integer node : visited) {
                    ans[cnt] = node;
                    cnt += 1;
                }
                return ans;
            }
        }

        return new int[0];
    }
}
```

## æŠ„å®˜æ–¹ç­”æ¡ˆçš„é¢˜è§£2

> æ¥è‡ª[å®˜æ–¹é¢˜è§£](https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/)

æ‹“æ‰‘æ’åºï¼Œå¯ä»¥ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢æ¥å®ç°ã€‚

æ·±åº¦ä¼˜å…ˆï¼Œç»“åˆæ ˆå®ç°ã€‚æŠ„ä¸‹ç­”æ¡ˆï¼šç¨å¾®æœ‰ç‚¹ç»•çš„åœ°æ–¹åœ¨äºå…¥æ ˆçš„æ–¹å¼ï¼Œè¿™é‡Œæ˜¯ä»åå¾€å‰æ”¾ï¼Œindexé€’å‡ã€‚

```java
class Solution {
    List<List<Integer>> edges;
    int[] visited;
    int[] result;
    int index;
    boolean valid = true;

    private void dfs(int node) {
        visited[node] = 1;

        for (int v : edges.get(node)) {
            if (visited[v] == 0) {
                dfs(v);
                if (!valid) {
                    return;
                }
            } else if (visited[v] == 1) {
                valid = false;
                return;
            }
        }

        visited[node] = 2;
        result[index--] = node;
    }

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<>();
        visited = new int[numCourses];
        result = new int[numCourses];
        index = numCourses-1;

        for (int i=0; i<numCourses; i+=1) {
            edges.add(new ArrayList<>());
        }
        for (var pre : prerequisites) {
            edges.get(pre[1]).add(pre[0]);
        }

        for (int i=0; i<numCourses && valid; i+=1) {
            if (visited[i] == 0) {
                dfs(i);
            }
        }

        if (!valid) {
            return new int[0];
        }

        return result;
    }
}
```

## ä»¥åŠé¢˜è§£3

å¹¿åº¦ä¼˜å…ˆæœç´¢å®ç°ï¼Œç»“åˆä¸€ä¸ªå…¥åº¦è¡¨ã€‚å¦‚æœæŸä¸ªèŠ‚ç‚¹çš„å…¥åº¦ä¸º0ï¼Œåˆ™å¯ä»¥ä¿®ç‚¼ï¼›ä¿®ç‚¼ä¹‹åï¼ŒæŠŠè¿™ä¸ªèŠ‚ç‚¹ç›¸è¿çš„èŠ‚ç‚¹å…¥åº¦-1ã€‚

è¿™ä¸ªæ€è·¯è·Ÿæˆ‘è‡ªå·±æ€è€ƒçš„æ€è·¯ç›¸è¿‘ï¼Œä¸è¿‡ç”¨å…¥åº¦çš„æ¦‚å¿µæ¥å®ç°æ‰€æœ‰å‰ç½®è¯¾ç¨‹ä¿®ç‚¼çš„åˆ¤æ–­ã€‚

ä¸‹é¢ä¹Ÿæ˜¯æŠ„çš„ç­”æ¡ˆï¼š

```java
class Solution {
    List<List<Integer>> edges;
    int[] indeg;
    int[] result;
    int index;

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<>();
        for (int i=0; i<numCourses; i+=1) {
            edges.add(new ArrayList<>());
        }
        indeg = new int[numCourses];
        result = new int[numCourses];
        index = 0;

        for (var pre : prerequisites) {
            edges.get(pre[1]).add(pre[0]);
            indeg[pre[0]] += 1;
        }

        Queue<Integer> queue = new LinkedList<>();

        for (int i=0; i<numCourses; i+=1) {
            if (indeg[i] == 0) {
                queue.offer(i);
            }
        }

        while (!queue.isEmpty()) {
            int u = queue.poll();
            result[index++] = u;
            for (int v : edges.get(u)) {
                indeg[v] -= 1;
                if (indeg[v] == 0) {
                    queue.offer(v);
                }
            }
        }

        if (index != numCourses) {
            return new int[0];
        }

        return result;
    }
}
```
